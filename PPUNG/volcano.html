<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>인터랙티브 3D 화산</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #111;
        font-family: "Arial", sans-serif;
      }
      #info {
        position: absolute;
        top: 20px;
        width: 100%;
        text-align: center;
        color: white;
        pointer-events: none;
        text-shadow: 1px 1px 2px black;
        z-index: 10;
      }
      h1 {
        margin: 0;
        font-size: 24px;
      }
      p {
        font-size: 14px;
        color: #ccc;
      }
    </style>

    <!-- 중요: ES Module 대신 일반 스크립트 태그로 라이브러리를 불러옵니다 (버전 r128) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls 불러오기 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  </head>
  <body>
    <div id="info">
      <h1>3D 화산 시뮬레이션</h1>
      <p>
        마우스 드래그: 회전 | 휠: 확대/축소 |
        <strong>화면 클릭: 대폭발!</strong>
      </p>
    </div>

    <script>
      // 전역 변수 THREE를 사용합니다.

      // 1. 씬(Scene) 설정
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111111);
      scene.fog = new THREE.Fog(0x111111, 20, 100);

      // 2. 카메라(Camera) 설정
      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 20, 40);

      // 3. 렌더러(Renderer) 설정
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // 4. 컨트롤(OrbitControls) 설정
      // 일반 스크립트 방식에서는 THREE.OrbitControls로 접근합니다.
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // 5. 조명(Lights) 설정
      const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
      scene.add(ambientLight);

      const moonLight = new THREE.DirectionalLight(0xffffff, 0.5);
      moonLight.position.set(10, 20, 10);
      moonLight.castShadow = true;
      scene.add(moonLight);

      const lavaLight = new THREE.PointLight(0xff4500, 5, 50);
      lavaLight.position.set(0, 10, 0);
      scene.add(lavaLight);

      // 6. 화산 모델 만들기
      const volcanoGroup = new THREE.Group();
      const geometry = new THREE.CylinderGeometry(5, 25, 20, 12);

      const positionAttribute = geometry.attributes.position;
      for (let i = 0; i < positionAttribute.count; i++) {
        const y = positionAttribute.getY(i);
        if (y < 10) {
          const x = positionAttribute.getX(i);
          const z = positionAttribute.getZ(i);
          positionAttribute.setX(i, x + (Math.random() - 0.5) * 2);
          positionAttribute.setZ(i, z + (Math.random() - 0.5) * 2);
        }
      }
      geometry.computeVertexNormals();

      const material = new THREE.MeshStandardMaterial({
        color: 0x5d4037,
        flatShading: true,
        roughness: 1,
      });

      const volcano = new THREE.Mesh(geometry, material);
      volcano.position.y = 10;
      volcano.castShadow = true;
      volcano.receiveShadow = true;
      volcanoGroup.add(volcano);

      const groundGeo = new THREE.PlaneGeometry(200, 200);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      scene.add(volcanoGroup);

      // 7. 파티클 시스템
      const particles = [];

      class Particle {
        constructor(isExplosion = false) {
          const size = Math.random() * 0.5 + 0.2;
          const geo = new THREE.DodecahedronGeometry(size, 0);
          const color = new THREE.Color();
          color.setHSL(Math.random() * 0.1 + 0.05, 1, 0.5);

          const mat = new THREE.MeshBasicMaterial({ color: color });
          this.mesh = new THREE.Mesh(geo, mat);

          this.mesh.position.set(
            (Math.random() - 0.5) * 4,
            18,
            (Math.random() - 0.5) * 4
          );

          const force = isExplosion ? 1.5 : 0.5;
          this.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 10 * force,
            (Math.random() * 10 + 10) * force,
            (Math.random() - 0.5) * 10 * force
          );

          this.gravity = 0.5;
          this.life = 1.0;

          scene.add(this.mesh);
        }

        update() {
          this.mesh.position.add(
            new THREE.Vector3(
              this.velocity.x * 0.05,
              this.velocity.y * 0.05,
              this.velocity.z * 0.05
            )
          );
          this.velocity.y -= this.gravity;
          this.mesh.rotation.x += 0.1;
          this.mesh.rotation.z += 0.1;

          if (this.mesh.position.y < 0) {
            this.life = 0;
          }
        }

        dispose() {
          scene.remove(this.mesh);
          this.mesh.geometry.dispose();
          this.mesh.material.dispose();
        }
      }

      // 8. 애니메이션 루프
      function animate() {
        requestAnimationFrame(animate);

        if (Math.random() > 0.8) {
          particles.push(new Particle(false));
        }

        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.update();
          if (p.life <= 0) {
            p.dispose();
            particles.splice(i, 1);
          }
        }

        lavaLight.intensity = 5 + Math.random() * 2;
        controls.update();
        renderer.render(scene, camera);
      }

      // 9. 이벤트 리스너
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      window.addEventListener("pointerdown", () => {
        for (let i = 0; i < 60; i++) {
          particles.push(new Particle(true));
        }
        camera.position.y += 0.5;
        setTimeout(() => {
          camera.position.y -= 0.5;
        }, 50);
      });

      animate();
    </script>
  </body>
</html>
